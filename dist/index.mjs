import{mkdir as y,rename as F}from"fs/promises";import{dirname as b}from"path";import R from"p-map";import{createWriteStream as v}from"fs";import{request as u}from"undici";var x=class{static concurrency=4;static setConcurrency(t){this.concurrency=t}static async existsResource(t){try{let{statusCode:r}=await u(t,{method:"HEAD"});return r>=200&&r<300}catch{return!1}}static async getResource(t){let{body:r}=await u(t);return r.text()}static async getResourceFromJson(t){return c.fromJson(await this.getResource(t))}static async postJson(t,r){let{body:e}=await u(t,{method:"POST",body:c.toJson(r),headers:{"Content-Type":"application/json"}});return await e.json()}static downloadFile(t,r,e={saveToTempFile:!1}){if(e.saveToTempFile&&(r=l.getTmpPath()),r===null)throw new Error("File path not found");return this.download(t,r,e.onProgress)}static async downloadSafeFile(t,r,e={}){if(r===null)throw new Error("File path not found");return await this.download(t,`${r}.safe`,e.onProgress),await F(`${r}.safe`,r)}static async downloadFiles(t,r={}){await R(t,async e=>{if(await this.verifyFileHash(e)){r.afterDownload&&r.afterDownload({url:e.sourceUrl});return}await this.download(e.sourceUrl,e.destinationPath,r.onProgress,r.beforeDownload,r.afterDownload)},{concurrency:this.concurrency})}static async download(t,r,e,n,i){await y(b(r),{recursive:!0});let{statusCode:s,headers:o,body:m}=await u(t);if(s>=400)throw new Error(`Failed to download ${t} with status code ${s}`);let h=o.location;if(s>300&&s<400&&h)return this.download(h,r,e,n,i);if(e){let d=0,g=+(o["content-length"]||0);m.on("data",f=>{e({url:t,transferred:d+=f.byteLength,total:g})})}return n&&n({url:t}),new Promise((d,g)=>{m.pipe(v(r)).on("finish",()=>{d(r),i&&i({url:t})}).on("error",f=>g(f))})}static async verifyFileHash(t){if(!t.sha1)return!1;let r;try{r=await a.getHashFromFile(t.destinationPath,"sha1")}catch{return!1}return t.sha1===r}};var c=class{static fromJson(t){return JSON.parse(t)}static toJson(t,r=!1){return r?JSON.stringify(t,null,4):JSON.stringify(t)}};import{randomBytes as L}from"crypto";import{tmpdir as T}from"os";import{resolve as P}from"path";var l=class{static getTmpPath(){return P(T(),L(16).toString("hex"))}};import{createHash as U}from"crypto";import{readFile as J}from"fs/promises";var a=class{static getHash(t,r){return U(r).update(t).digest("hex")}static async getHashFromFile(t,r){return this.getHash(await J(t),r)}};import{extname as S}from"path";import D from"adm-zip";var w=class{static unzip(t,r,e=[],n){let i=new D(t),s=[];return i.getEntries().forEach(o=>{if(o.isDirectory||e.length>0&&!e.includes(S(o.entryName)))return;n&&n(o.header.compressedSize);let m=a.getHash(o.getData(),"sha1");s.push({path:o.entryName,sha1:m}),i.extractEntryTo(o,r,!0,!0)}),s}};var H=(r=>(r.Allow="allow",r.Disallow="disallow",r))(H||{}),C=(e=>(e.Linux="linux",e.Osx="osx",e.Windows="windows",e))(C||{});export{H as Action,a as HashHelper,x as HttpHelper,c as JsonHelper,C as Name,l as StorageHelper,w as ZipHelper};
//# sourceMappingURL=index.mjs.map