{"version":3,"sources":["../src/helpers/HttpHelper.ts","../src/helpers/JsonHelper.ts","../src/helpers/StorageHelper.ts","../src/helpers/HashHelper.ts","../src/helpers/ZipHelper.ts","../src/interfaces/Profile.ts"],"sourcesContent":["import { mkdir, rename } from \"fs/promises\"\nimport { dirname } from \"path\"\nimport { URL } from \"url\"\n\nimport pMap from \"p-map\"\n\nimport { HashHelper, JsonData, JsonHelper, StorageHelper } from \".\"\nimport { createWriteStream } from \"fs\"\nimport { request } from \"undici\"\n\ninterface Progress {\n    url: string | URL\n    transferred: number\n    total: number\n}\ntype onProgressFunction = (progress: Progress) => void\n\nexport interface File {\n    sourceUrl: string\n    destinationPath: string\n    sha1?: string\n}\n\nexport class HttpHelper {\n    private static concurrency = 4\n\n    /**\n     * Изменить количество одновременно скачиваемых файлов\n     * @param concurrency\n     */\n    public static setConcurrency(concurrency: number) {\n        this.concurrency = concurrency\n    }\n\n    /**\n     * Проверка наличия ресурса\n     * @param url - строка или объект URL, содержащий ссылку на ресурс\n     * @returns Promise, который вернёт `true`, в случае существования ресурса или `false` при его отсутствии или ошибке\n     */\n    public static async existsResource(url: string | URL) {\n        try {\n            const { statusCode } = await request(url, { method: \"HEAD\" })\n            return statusCode >= 200 && statusCode < 300\n        } catch (error) {\n            return false\n        }\n    }\n\n    /**\n     * Чтение ресурса\n     * @param url - строка или объект URL, содержащий ссылку на ресурс\n     * @returns Promise, который вернёт содержимое ресурса, в случае успеха\n     */\n    public static async getResource(url: string | URL) {\n        const { body } = await request(url)\n        return body.text()\n    }\n\n    /**\n     * Получение данных из JSON ресурса\n     * @param url - строка или объект URL, содержащий ссылку на ресурс\n     * @returns Promise, который вернёт обработанный объект, в случае успеха\n     */\n    public static async getResourceFromJson<T>(url: string | URL): Promise<T> {\n        return JsonHelper.fromJson<T>(await this.getResource(url))\n    }\n\n    /**\n     * Отправка POST запроса и получение результата из JSON\n     * @param url - строка или объект URL, содержащий ссылку на ресурс\n     * @returns Promise, который вернёт обработанный объект, в случае успеха\n     */\n    public static async postJson<T>(\n        url: string | URL,\n        json: JsonData,\n    ): Promise<T> {\n        const { body } = await request(url, {\n            method: \"POST\",\n            body: JsonHelper.toJson(json),\n            headers: { \"Content-Type\": \"application/json\" },\n        })\n        return (await body.json()) as T\n    }\n\n    /**\n     * Скачивание файла\n     * @param url - строка или объект URL, содержащий ссылку на файл\n     * @param filePath - путь до сохраняемого файла\n     * @param options - список опций:\n     * @param options.onProgress - коллбэк, в который передаётся текущий прогресс загрузки, если объявлен\n     * @param options.saveToTempFile - сохранять во временный файл, по умолчанию `false`\n     * @returns Promise который вернёт название файла в случае успеха\n     */\n    public static downloadFile(\n        url: string | URL,\n        filePath: string | null,\n        options: {\n            onProgress?: onProgressFunction\n            saveToTempFile?: boolean\n        } = {\n            saveToTempFile: false,\n        },\n    ) {\n        if (options.saveToTempFile) filePath = StorageHelper.getTmpPath()\n        if (filePath === null) throw new Error(\"File path not found\")\n\n        return this.download(url, filePath, options.onProgress)\n    }\n\n    /**\n     * Скачивание во временный файл с последующим переименованием в оригинал\n     * @param url - строка или объект URL, содержащий ссылку на файл\n     * @param filePath - путь до сохраняемого файла\n     * @param options - список опций:\n     * @param options.onProgress - коллбэк, в который передаётся текущий прогресс загрузки, если объявлен\n     */\n    public static async downloadSafeFile(\n        url: string | URL,\n        filePath: string,\n        options: {\n            onProgress?: onProgressFunction\n        } = {},\n    ) {\n        if (filePath === null) throw new Error(\"File path not found\")\n\n        await this.download(url, `${filePath}.safe`, options.onProgress)\n        return await rename(`${filePath}.safe`, filePath)\n    }\n\n    /**\n     * Скачивание файлов\n     * @param filesList - список файлов\n     * @param options - список опций:\n     * @param options.onProgress - коллбэк, в который передаётся текущий прогресс загрузки, если объявлен\n     * @param options.saveToTempFile - сохранять во временный файл, по умолчанию `false`\n     */\n    public static async downloadFiles(\n        filesList: File[],\n        options: {\n            onProgress?: onProgressFunction\n            beforeDownload?: (data: { url: string | URL }) => void\n            afterDownload?: (data: { url: string | URL }) => void\n        } = {},\n    ) {\n        await pMap(\n            filesList,\n            async (file) => {\n                if (await this.verifyFileHash(file)) {\n                    if (options.afterDownload)\n                        options.afterDownload({\n                            url: file.sourceUrl,\n                        })\n                    return\n                }\n\n                await this.download(\n                    file.sourceUrl,\n                    file.destinationPath,\n                    options.onProgress,\n                    options.beforeDownload,\n                    options.afterDownload,\n                )\n            },\n            { concurrency: this.concurrency },\n        )\n    }\n\n    /**\n     * Внутренняя функция скачивания файла\n     * @param url - строка или объект URL, содержащий ссылку на файл\n     * @param filePath - путь до сохраняемого файла\n     * @param onProgress - коллбэк, в который передаётся текущий прогресс загрузки, если объявлен\n     * @returns Promise, который вернёт название файла, в случае успеха\n     */\n    private static async download(\n        url: string | URL,\n        filePath: string,\n        onProgress?: onProgressFunction,\n        beforeDownload?: (data: { url: string | URL }) => void,\n        afterDownload?: (data: { url: string | URL }) => void,\n    ): Promise<string> {\n        await mkdir(dirname(filePath), { recursive: true })\n\n        const { statusCode, headers, body } = await request(url)\n\n        if (statusCode >= 400) {\n            throw new Error(\n                `Failed to download ${url} with status code ${statusCode}`,\n            )\n        }\n\n        const location = <string | undefined>headers[\"location\"]\n        // handle redirects\n        if (statusCode > 300 && statusCode < 400 && !!location) {\n            return this.download(\n                location,\n                filePath,\n                onProgress,\n                beforeDownload,\n                afterDownload,\n            )\n        }\n\n        if (onProgress) {\n            let transferred = 0\n            const total = +(headers[\"content-length\"] || 0)\n\n            body.on(\"data\", (chunk) => {\n                onProgress({\n                    url,\n                    transferred: (transferred += chunk.byteLength),\n                    total,\n                })\n            })\n        }\n\n        if (beforeDownload) {\n            beforeDownload({ url })\n        }\n\n        return new Promise((resolve, reject) => {\n            body.pipe(createWriteStream(filePath))\n                .on(\"finish\", () => {\n                    resolve(filePath)\n                    if (afterDownload) {\n                        afterDownload({ url })\n                    }\n                })\n                .on(\"error\", (error) => reject(error))\n        })\n    }\n\n    private static async verifyFileHash(file: File) {\n        if (!file.sha1) return false\n\n        let currentHash\n        try {\n            currentHash = await HashHelper.getHashFromFile(\n                file.destinationPath,\n                \"sha1\",\n            )\n        } catch (error) {\n            return false\n        }\n\n        return file.sha1 === currentHash\n    }\n}\n","// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type JsonData = Record<string, any> | any[]\n\n/**\n * Класс хелпер для работы с JSON\n */\nexport class JsonHelper {\n    /**\n     * Преобразовать JSON строку в объект / массив\n     * @param string JSON строка\n     * @returns `Object | Array`\n     */\n    static fromJson<T>(string: string): T {\n        return JSON.parse(string)\n    }\n\n    /**\n     * Преобразовать объект / массив в JSON строку\n     * @param object Пробразуемый объект / массив\n     * @param pretty Форматировать вывод отступами или вывести в одну строку (по умолчанию `false`)\n     * @returns JSON сторка\n     */\n    static toJson(object: JsonData, pretty = false): string {\n        return pretty ? JSON.stringify(object, null, 4) : JSON.stringify(object)\n    }\n}\n","import { randomBytes } from \"crypto\"\nimport { tmpdir } from \"os\"\nimport { resolve } from \"path\"\n\nexport class StorageHelper {\n    /**\n     * Генерирует путь к времененной папке / файлу во временной деректории операционной системы\n     * @returns Путь к времененной папке / файлу\n     * @example `/tmp/962f2250ed89c7c013e4b442dcd620a5` или `C:\\\\Users\\\\user\\\\AppData\\\\Local\\\\Temp\\\\d32e9f17ca638349326f9fa7228a7920`\n     */\n    static getTmpPath() {\n        return resolve(tmpdir(), randomBytes(16).toString(\"hex\"))\n    }\n}\n","import { BinaryLike, createHash } from \"crypto\"\nimport { readFile } from \"fs/promises\"\n\nexport class HashHelper {\n    static getHash(str: BinaryLike, type: string) {\n        return createHash(type).update(str).digest(\"hex\")\n    }\n\n    static async getHashFromFile(path: string, type: string) {\n        return this.getHash(await readFile(path), type)\n    }\n}\n","import { extname } from \"path\"\n\nimport AdmZip from \"adm-zip\"\nimport { HashHelper } from \"./HashHelper\"\n\nexport class ZipHelper {\n    /**\n     * Распаковка архива в папку\n     * @param archive - путь до архива\n     * @param destDir - конечная папка\n     * @param whitelist - распаковать файлы с определённым расширением (указывать с точкой, например: .so)\n     * @param onProgress - функция для отслеживания прогресса распаковки\n     * @returns список распакованных файлов\n     */\n    static unzip(\n        archive: string,\n        destDir: string,\n        whitelist: string[] = [],\n        onProgress?: (size: number) => void,\n    ) {\n        const zip = new AdmZip(archive)\n        const extractedFiles: { path: string; sha1: string }[] = []\n\n        zip.getEntries().forEach((entry) => {\n            if (\n                entry.isDirectory ||\n                (whitelist.length > 0 &&\n                    !whitelist.includes(extname(entry.entryName)))\n            )\n                return\n\n            onProgress && onProgress(entry.header.compressedSize)\n            const sha1 = HashHelper.getHash(entry.getData(), \"sha1\")\n            extractedFiles.push({\n                path: entry.entryName,\n                sha1,\n            })\n            zip.extractEntryTo(entry, destDir, true, true)\n        })\n\n        return extractedFiles\n    }\n}\n","import * as proto from \"@aurora-launcher/proto\";\nexport interface Profile extends proto.ProfileResponse {}\n\nexport interface ProfileLibrary {\n    path: string\n    sha1: string\n    type: \"library\" | \"native\"\n    rules: LibraryRule[]\n    ignoreClassPath?: boolean\n}\n\nexport interface LibraryRule {\n    action: Action\n    os?: OS\n}\n\nexport interface OS {\n    name: Name\n    arch?: string\n    version?: string\n}\n\nexport enum Action {\n    Allow = \"allow\",\n    Disallow = \"disallow\",\n}\n\nexport enum Name {\n    Linux = \"linux\",\n    Osx = \"osx\",\n    Windows = \"windows\",\n}\n\nexport type ProfileServerConfig = proto.ServerConfig;\n\n// export interface ProfileOptional {\n//     id: number\n//     name: string\n//     description: string\n//     mark: boolean\n//     filename: string\n//     conflict: number[]\n//     children: ProfileOptional[]\n// }\n"],"mappings":"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","names":["mkdir","rename","dirname","pMap","createWriteStream","request","HttpHelper","concurrency","url","statusCode","body","JsonHelper","json","filePath","options","StorageHelper","rename","filesList","pMap","file","onProgress","beforeDownload","afterDownload","mkdir","dirname","headers","location","transferred","total","chunk","resolve","reject","error","currentHash","HashHelper","JsonHelper","string","object","pretty","randomBytes","tmpdir","resolve","StorageHelper","createHash","readFile","HashHelper","str","type","path","extname","AdmZip","ZipHelper","archive","destDir","whitelist","onProgress","zip","AdmZip","extractedFiles","entry","extname","sha1","HashHelper","Action","Name"]}